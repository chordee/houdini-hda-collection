MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY"

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="node_type"
Content-Type: text/plain

Lop

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.init"
Content-Type: text/plain

type = chordee::dev::convert_ai_to_mtlx::1.0
matchesdef = 0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.def"
Content-Type: text/plain

comment ""
position -2.5711 0.850661
connectornextid 2
flags =  lock off model off template off footprint off xray off bypass off display on render off highlight off unload off savedata off compress on colordefault on exposed on debug off
outputsNamed3
{
1 "output1"
}
inputsNamed3
{
0 	reference3 0 1 "input1"
}
inputs
{
0 	reference3 0 1
}
stat
{
  create -1
  modify -1
  author chordee.lin@MoonShineFx06.moonshine.ad
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":""
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.inp"
Content-Type: text/plain

1
0 0 6.8941999999999997 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/pythonscript2.init"
Content-Type: text/plain

type = pythonscript
matchesdef = 1

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/pythonscript2.def"
Content-Type: text/plain

comment ""
position 0 6.1118
connectornextid 2
flags =  lock off model off template off footprint off xray off bypass off display off render on highlight off unload off savedata off compress on colordefault on exposed on debug off
outputsNamed3
{
1 "output1"
}
inputsNamed3
{
0 	(0) "" 1 "input1"
}
inputs
{
0 	(0) 0 1
}
stat
{
  create -1
  modify -1
  author chord@LAPTOP-ULJICLO8
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/pythonscript2.parm"
Content-Type: text/plain

{
version 0.8
python	[ 0	locks=0 ]	(	"from pxr import Usd, UsdShade, Sdf
node = hou.pwd()
stage = node.editableStage()


# Add code to modify the stage.
# Use drop down menu to select examples.

def check_inputs(shader):
    inputs = shader.GetInputs()
    for i in inputs:
        source = i.GetConnectedSource()
        if source is not None:
            type_name = i.GetTypeName()
            if source[1] != 'out':
                source_type = Sdf.ValueTypeNames.Color3f
                if type_name == 'float':
                    source_type = Sdf.ValueTypeNames.Float
                elif type_name == 'color3f':
                    source_type = Sdf.ValueTypeNames.Color3f
                elif type_name == 'vector3f':
                    source_type = Sdf.ValueTypeNames.Vector3f
                elif type_name == 'token':
                    source_type = Sdf.ValueTypeNames.Token
                elif source_type == 'string':
                    source_type = Sdf.ValueTypeNames.String
                i.ConnectToSource(source[0].GetOutput('out') if source[0].GetPrim().HasAttribute(
                    'outputs:out') else source[0].CreateOutput('out', source_type))


def get_output_from_source(source):
    prim = source[0].GetPrim()
    shader = source[0]
    name = source[1]
    type = source[2]
    attr = prim.GetAttribute('outputs:' + name)
    output = shader.GetOutput(name)
    return output


def convert_material(material):
    prim = material.GetPrim()
    if prim.HasAttribute('outputs:arnold:surface'):
        output = material.CreateOutput('mtlx:surface', Sdf.ValueTypeNames.Token)
        orig_output = material.GetOutput('arnold:surface')
        if orig_output.HasConnectedSource():
            source = orig_output.GetConnectedSource()
            if not source[0].GetPrim().HasAttribute('outpupts:out'):
                out = source[0].CreateOutput('out', Sdf.ValueTypeNames.Token)
            else:
                out = source[0].GetOutput('out')
            output.ConnectToSource(out)
    if prim.HasAttribute('outputs:arnold:displacement'):
        output = material.CreateOutput('mtlx:displacement', Sdf.ValueTypeNames.Token)
        orig_output = material.GetOutput('arnold:displacement')
        if orig_output.HasConnectedSource():
            source = orig_output.GetConnectedSource()
            if not source[0].GetPrim().HasAttribute('outpupts:out'):
                out = source[0].CreateOutput('out', Sdf.ValueTypeNames.Token)
            else:
                out = source[0].GetOutput('out')
            output.ConnectToSource(out)


def convert_standard_surface(shader):
    shader.GetIdAttr().Set('ND_standard_surface_surfaceshader')
    prim = shader.GetPrim()
    attrs = prim.GetAttributes()
    inputs = shader.GetInputs()
    input_names = [x.GetAttr().GetName() for x in inputs]
    attr_names = [x.GetName() for x in attrs]
    check_inputs(shader)

def convert_image(shader):
    shader.GetIdAttr().Set('ND_image_color3')
    prim = shader.GetPrim()
    attr = prim.CreateAttribute('inputs:file', Sdf.ValueTypeNames.String)
    file_path = prim.GetAttribute('inputs:filename').Get()
    attr.Set(file_path.replace('<udim>', '<UDIM>'))


def convert_normalmap(shader):
    shader.GetIdAttr().Set('ND_normalmap')
    input = shader.CreateInput('in', Sdf.ValueTypeNames.Vector3f)
    orig_input = shader.GetInput('input')
    source = orig_input.GetConnectedSource()
    input.ConnectToSource(source[0].GetPrim().GetAttribute('outputs:out').GetPath())
    check_inputs(shader)


def convert_range(shader):
    orig_input = shader.GetInput('input')
    orig_input_names = [x.GetBaseName() for x in shader.GetInputs()]
    outputs = shader.GetOutputs()
    output_names = [x.GetBaseName() for x in outputs]
    type_name = orig_input.GetTypeName()
    if 'out' in output_names:
        shader.GetIdAttr().Set('ND_range_vector3')
        input_type = Sdf.ValueTypeNames.Vector3f
    else:
        shader.GetIdAttr().Set('ND_range_float')
        input_type = Sdf.ValueTypeNames.Float
    input = shader.CreateInput('in', input_type)
    source = orig_input.GetConnectedSource()
    input.ConnectToSource(source[0].GetOutput('out') if source[0].GetPrim().HasAttribute(
        'outputs:out') else source[0].CreateOutput('out', input_type))
    names_match = {\"input_max\" : 'inhigh', 'input_min' : 'inlow', 'output_max' : 'outhigh', 'output_min' : 'outlow'}
    for orig_name in names_match.keys():
        if orig_name in orig_input_names:
            new_input = shader.CreateInput(names_match[orig_name], input_type)
            orig_val = shader.GetInput(orig_name).GetAttr().Get()
            orig_type_name = shader.GetInput(orig_name).GetTypeName()
            if input_type == Sdf.ValueTypeNames.Vector3f and orig_type_name == 'float':
                orig_val = (orig_val, orig_val, orig_val)
            new_input.GetAttr().Set(orig_val)
    check_inputs(shader)

def convert_displacement(shader):
    shader.GetIdAttr().Set('ND_displacement_float')
    prim = shader.GetPrim()
    orig_input = shader.GetInput('input')
    if not prim.HasAttribute('inputs:displacement'):
        input = shader.CreateInput('displacement', Sdf.ValueTypeNames.Float)
        source = orig_input.GetConnectedSource()
        source_output = get_output_from_source(source)
        if source_output.GetTypeName() == 'float':
            input.ConnectToSource(source[0].GetPrim().GetAttribute('outputs:out').GetPath())
        else:
            input.ConnectToSource(source[0].GetPrim().GetAttribute('outputs:out').GetPath())


def convert_clamp(shader):
    out_type = shader.GetOutput('out').GetTypeName()
    orig_input = shader.GetInput('input')
    source = orig_input.GetConnectedSource()
    if out_type == 'float':
        shader.GetIdAttr().Set('ND_clamp_float')
        input = shader.CreateInput('in', Sdf.ValueTypeNames.Float)
    else:
        shader.GetIdAttr().Set('ND_clamp_vector3')
        input = shader.CreateInput('in', Sdf.ValueTypeNames.Vector3f)
    input.ConnectToSource(source[0].GetPrim().GetAttribute('outputs:out').GetPath())
    check_inputs(shader)


def convert_layer(shader):
    shader.GetIdAttr().Set('ND_mix_surfaceshader')
    shader_name = shader.GetPrim().GetName()
    shader_path = shader.GetPrim().GetPath()
    orig_input1 = shader.GetInput('input1')
    orig_input1_source = orig_input1.GetConnectedSource()
    orig_input2 = shader.GetInput('input2')
    orig_input2_source = orig_input2.GetConnectedSource()
    
    input_fg = shader.CreateInput('fg', Sdf.ValueTypeNames.Token)
    input_bg = shader.CreateInput('bg', Sdf.ValueTypeNames.Token)
    input_mix = shader.CreateInput('mix', Sdf.ValueTypeNames.Float)
    input_bg.ConnectToSource(orig_input1_source[0].GetPrim().GetAttribute('outputs:out').GetPath())
    input_fg.ConnectToSource(orig_input2_source[0].GetPrim().GetAttribute('outputs:out').GetPath())
    

    orig_mix1_val = 1.0
    orig_mix1_source = None
    if shader.GetPrim().HasAttribute('inputs:mix1'):
        orig_mix1_val = shader.GetInput('mix1').GetAttr().Get()
        orig_mix1_source = shader.GetInput('mix1').GetConnectedSource()

    orig_mix2_val = 1.0
    orig_mix2_source = None
    if shader.GetPrim().HasAttribute('inputs:mix2'):
        orig_mix2_val = shader.GetInput('mix2').GetAttr().Get()
        orig_mix2_source = shader.GetInput('mix2').GetConnectedSource()

    add = UsdShade.Shader.Define(stage, str(shader_path) + '/' + shader_name + '_add')
    add.GetIdAttr().Set('ND_add_float')
    add.CreateOutput('out', Sdf.ValueTypeNames.Float)
    divide = UsdShade.Shader.Define(stage, str(shader_path) + '/' + shader_name + '_divide')
    divide.GetIdAttr().Set('ND_divide_float')
    divide.CreateOutput('out', Sdf.ValueTypeNames.Float)

    add.CreateInput('in1', Sdf.ValueTypeNames.Float).GetAttr().Set(orig_mix1_val)
    if orig_mix1_source is not None:
        add.GetInput('in1').ConnectToSource(orig_mix1_source[0].GetOutput(orig_mix1_source[1]))
    add.CreateInput('in2', Sdf.ValueTypeNames.Float).GetAttr().Set(orig_mix2_val)
    if orig_mix2_source is not None:
        add.GetInput('in2').ConnectToSource(orig_mix2_source[0].GetOutput(orig_mix2_source[1]))

    divide.CreateInput('in1', Sdf.ValueTypeNames.Float).GetAttr().Set(orig_mix2_val)
    if orig_mix2_source is not None:
        divide.GetInput('in1').ConnectToSource(orig_mix2_source[0].GetOutput(orig_mix2_source[1]))
    divide.CreateInput('in2', Sdf.ValueTypeNames.Float).ConnectToSource(add.GetOutput('out'))

    input_mix.ConnectToSource(divide.GetOutput('out'))

    check_inputs(add)
    check_inputs(divide)
    check_inputs(shader)


def convert_color_correct(shader):
    prim = shader.GetPrim()
    prim_path = str(prim.GetPath())
    sub_shaders = {'hsvadjust': ['ND_hsvadjust_color3'], 'saturation': ['ND_saturate_color3'], 'gamma': ['ND_range_color3FA'],
                   'liftmult': ['ND_multiply_color3FA'], 'liftadd': ['ND_add_color3FA'], 'gain': ['ND_add_color3FA'], 'contrast': ['ND_contrast_color3FA'], 'exposure': ['ND_multiply_color3FA'], 'exposurepwr': ['ND_power_float'], 'liftsubtract': ['ND_subtract_float'], 'parm2hue': ['ND_combine3_vector3'], 'mtlxseparate3c1': ['ND_separate3_color3']}
    for key in sub_shaders.keys():
        sub = UsdShade.Shader.Define(stage, prim_path + '/' + key)
        sub.GetIdAttr().Set(sub_shaders[key][0])
        sub_shaders[key].append(sub)
        if key == 'liftsubtract':
            sub.CreateOutput('out', Sdf.ValueTypeNames.Float)
            sub.CreateInput('in1', Sdf.ValueTypeNames.Float).GetAttr().Set(1.0)
            sub.CreateInput('in2', Sdf.ValueTypeNames.Float).ConnectToSource(shader.GetInput(
                'lift') if prim.HasAttribute('inputs:lift') else shader.CreateInput('lift', Sdf.ValueTypeNames.Float))
        elif key == 'exposurepwr':
            sub.CreateOutput('out', Sdf.ValueTypeNames.Float)
            sub.CreateInput('in1', Sdf.ValueTypeNames.Float).GetAttr().Set(2.0)
            sub.CreateInput('in2', Sdf.ValueTypeNames.Float).ConnectToSource(shader.GetInput('exposure') if prim.HasAttribute(
                'inputs:exposure') else shader.CreateInput('exposure', Sdf.ValueTypeNames.Float))
        elif key == 'parm2hue':
            sub.CreateOutput('out', Sdf.ValueTypeNames.Vector3f)
        else:
            sub.CreateOutput('out', Sdf.ValueTypeNames.Color3f)

    output = shader.CreateOutput('out', Sdf.ValueTypeNames.Color3f)
    output.ConnectToSource(sub_shaders['exposure'][1].CreateOutput('out', Sdf.ValueTypeNames.Color3f))

    sub_shaders['exposure'][1].CreateInput('in1', Sdf.ValueTypeNames.Color3f).ConnectToSource(
        sub_shaders['contrast'][1].GetOutput('out'))
    sub_shaders['exposure'][1].CreateInput('in2', Sdf.ValueTypeNames.Float).ConnectToSource(
        sub_shaders['exposurepwr'][1].GetOutput('out'))

    sub_shaders['mtlxseparate3c1'][1].CreateInput('in', Sdf.ValueTypeNames.Color3f).ConnectToSource(
        sub_shaders['exposure'][1].GetOutput('out'))
    shader.CreateOutput('outr', Sdf.ValueTypeNames.Float).ConnectToSource(
        sub_shaders['mtlxseparate3c1'][1].CreateOutput('outr', Sdf.ValueTypeNames.Float))
    shader.CreateOutput('outg', Sdf.ValueTypeNames.Float).ConnectToSource(
        sub_shaders['mtlxseparate3c1'][1].CreateOutput('outg', Sdf.ValueTypeNames.Float))
    shader.CreateOutput('outb', Sdf.ValueTypeNames.Float).ConnectToSource(
        sub_shaders['mtlxseparate3c1'][1].CreateOutput('outb', Sdf.ValueTypeNames.Float))

    sub_shaders['contrast'][1].CreateInput('in', Sdf.ValueTypeNames.Color3f).ConnectToSource(
        sub_shaders['gain'][1].GetOutput('out'))
    sub_shaders['contrast'][1].CreateInput('amount', Sdf.ValueTypeNames.Float).ConnectToSource(shader.GetInput(
        'contrast') if prim.HasAttribute('inputs:contrast') else shader.CreateInput('contrast', Sdf.ValueTypeNames.Float))
    sub_shaders['contrast'][1].CreateInput('pivot', Sdf.ValueTypeNames.Float).ConnectToSource(shader.GetInput(
        'contrastpivot') if prim.HasAttribute('inputs:contrastpivot') else shader.CreateInput('contrastpivot', Sdf.ValueTypeNames.Float))

    sub_shaders['gain'][1].CreateInput('in1', Sdf.ValueTypeNames.Color3f).ConnectToSource(
        sub_shaders['liftadd'][1].GetOutput('out'))
    sub_shaders['gain'][1].CreateInput('in2', Sdf.ValueTypeNames.Float).ConnectToSource(shader.GetInput(
        'gain') if prim.HasAttribute('inputs:gain') else shader.CreateInput('gain', Sdf.ValueTypeNames.Float))

    sub_shaders['liftadd'][1].CreateInput('in1', Sdf.ValueTypeNames.Color3f).ConnectToSource(
        sub_shaders['liftmult'][1].GetOutput('out'))
    sub_shaders['liftadd'][1].CreateInput('in2', Sdf.ValueTypeNames.Float).ConnectToSource(shader.GetInput(
        'lift') if prim.HasAttribute('inputs:lift') else shader.CreateInput('lift', Sdf.ValueTypeNames.Float))

    sub_shaders['liftmult'][1].CreateInput('in1', Sdf.ValueTypeNames.Color3f).ConnectToSource(
        sub_shaders['gamma'][1].GetOutput('out'))
    sub_shaders['liftmult'][1].CreateInput('in2', Sdf.ValueTypeNames.Float).ConnectToSource(
        sub_shaders['liftsubtract'][1].GetOutput('out'))

    sub_shaders['gamma'][1].CreateInput('in', Sdf.ValueTypeNames.Color3f).ConnectToSource(
        sub_shaders['saturation'][1].GetOutput('out'))
    sub_shaders['gamma'][1].CreateInput('gamma', Sdf.ValueTypeNames.Float).ConnectToSource(shader.GetInput(
        'gamma') if prim.HasAttribute('inputs:gamma') else shader.CreateInput('gamma', Sdf.ValueTypeNames.Float))

    sub_shaders['saturation'][1].CreateInput('in', Sdf.ValueTypeNames.Color3f).ConnectToSource(
        sub_shaders['hsvadjust'][1].GetOutput('out'))
    sub_shaders['saturation'][1].CreateInput('amount', Sdf.ValueTypeNames.Float).ConnectToSource(shader.GetInput(
        'saturation') if prim.HasAttribute('inputs:saturation') else shader.CreateInput('saturation', Sdf.ValueTypeNames.Float))

    sub_shaders['hsvadjust'][1].CreateInput('amount', Sdf.ValueTypeNames.Float).ConnectToSource(
        sub_shaders['parm2hue'][1].GetOutput('out'))
    sub_shaders['hsvadjust'][1].CreateInput('in', Sdf.ValueTypeNames.Color3f).ConnectToSource(shader.GetInput(
        'in') if prim.HasAttribute('inputs:in') else shader.CreateInput('in', Sdf.ValueTypeNames.Color3f))

    sub_shaders['parm2hue'][1].CreateInput('in1', Sdf.ValueTypeNames.Float).ConnectToSource(shader.GetInput(
        'hue') if prim.HasAttribute('inputs:hue') else shader.CreateInput('hue', Sdf.ValueTypeNames.Float))
    sub_shaders['parm2hue'][1].CreateInput('in2', Sdf.ValueTypeNames.Float).GetAttr().Set(1.0)
    sub_shaders['parm2hue'][1].CreateInput('in3', Sdf.ValueTypeNames.Float).GetAttr().Set(1.0)

    source = shader.GetInput('input').GetConnectedSource()
    shader.CreateInput('in', Sdf.ValueTypeNames.Color3f).ConnectToSource(source[0].GetPrim().GetAttribute('outputs:out').GetPath())
    shader.GetIdAttr().Set('')
    UsdShade.NodeGraph.Define(stage, shader.GetPrim().GetPath())
    if prim.HasAttribute('inputs:contrast_pivot'):
        prim.GetAttribute('inputs:contrastpivot').Set(prim.GetAttribute('inputs:contrast_pivot').Get())
    if prim.HasAttribute('inputs:multiply'):
        prim.GetAttribute('inputs:gain').Set(prim.GetAttribute('inputs:multiply').Get()[0])
    if prim.HasAttribute('inputs:hue_shift'):
        prim.GetAttribute('inputs:hue').Set(prim.GetAttribute('inputs:hue_shift').Get())


def convert_ramp_rgb(shader):
    prim = shader.GetPrim()
    prim_path = str(prim.GetPath())
    shader.CreateOutput('out', Sdf.ValueTypeNames.Color3f)
    if not prim.HasAttribute('inputs:input'):
        shader.CreateInput('input', Sdf.ValueTypeNames.Color3f)
    sub_shaders = {'numkeys': ['ND_constant_float'], 'invlinear': [
        'ND_hinvlinear_float'], 'uniformramp': ['ND_huniformramp_color3']}
    for key in sub_shaders.keys():
        sub = UsdShade.Shader.Define(stage, prim_path + '/' + key)
        sub.GetIdAttr().Set(sub_shaders[key][0])
        sub_shaders[key].append(sub)
    positions = prim.GetAttribute('inputs:position').Get()

    colors = prim.GetAttribute('inputs:color').Get()
    sub_shaders['numkeys'][1].CreateInput('value', Sdf.ValueTypeNames.Float).GetAttr().Set(len(positions))
    sub_shaders['numkeys'][1].CreateOutput('out', Sdf.ValueTypeNames.Float)
    sub_shaders['invlinear'][1].CreateInput('num', Sdf.ValueTypeNames.Float).ConnectToSource(
        sub_shaders['numkeys'][1].GetOutput('out'))
    sub_shaders['invlinear'][1].CreateInput('ramp', Sdf.ValueTypeNames.Float).ConnectToSource(shader.GetInput('input'))
    sub_shaders['uniformramp'][1].CreateInput('num', Sdf.ValueTypeNames.Float).ConnectToSource(
        sub_shaders['numkeys'][1].GetOutput('out'))
    sub_shaders['uniformramp'][1].CreateInput('ramp', Sdf.ValueTypeNames.Float).ConnectToSource(
        sub_shaders['invlinear'][1].CreateOutput('out', Sdf.ValueTypeNames.Float))

    for idx, i in enumerate(positions):
        sub_shaders['invlinear'][1].CreateInput('key' + str(idx), Sdf.ValueTypeNames.Float).GetAttr().Set(i)
        sub_shaders['uniformramp'][1].CreateInput(
            'value' + str(idx), Sdf.ValueTypeNames.Color3f).GetAttr().Set(colors[idx])
    shader.GetIdAttr().Set('')
    shader.GetOutput('out').ConnectToSource(sub_shaders['uniformramp'][1].CreateOutput('out', Sdf.ValueTypeNames.Color3f))
    UsdShade.NodeGraph.Define(stage, shader.GetPrim().GetPath())
    check_inputs(shader)


def convert_ramp_float(shader):
    prim = shader.GetPrim()
    prim_path = str(prim.GetPath())
    shader.CreateOutput('out', Sdf.ValueTypeNames.Float)
    if not prim.HasAttribute('inputs:input'):
        shader.CreateInput('input', Sdf.ValueTypeNames.Float)
    sub_shaders = {'numkeys': ['ND_constant_float'], 'invlinear': [
        'ND_hinvlinear_float'], 'uniformramp': ['ND_huniformramp_float']}
    for key in sub_shaders.keys():
        sub = UsdShade.Shader.Define(stage, prim_path + '/' + key)
        sub.GetIdAttr().Set(sub_shaders[key][0])
        sub_shaders[key].append(sub)
    positions = prim.GetAttribute('inputs:position').Get()

    values = prim.GetAttribute('inputs:value').Get()
    sub_shaders['numkeys'][1].CreateInput('value', Sdf.ValueTypeNames.Float).GetAttr().Set(len(positions))
    sub_shaders['numkeys'][1].CreateOutput('out', Sdf.ValueTypeNames.Float)
    sub_shaders['invlinear'][1].CreateInput('num', Sdf.ValueTypeNames.Float).ConnectToSource(
        sub_shaders['numkeys'][1].GetOutput('out'))
    sub_shaders['invlinear'][1].CreateInput('ramp', Sdf.ValueTypeNames.Float).ConnectToSource(shader.GetInput('input'))
    sub_shaders['uniformramp'][1].CreateInput('num', Sdf.ValueTypeNames.Float).ConnectToSource(
        sub_shaders['numkeys'][1].GetOutput('out'))
    sub_shaders['uniformramp'][1].CreateInput('ramp', Sdf.ValueTypeNames.Float).ConnectToSource(
        sub_shaders['invlinear'][1].CreateOutput('out', Sdf.ValueTypeNames.Float))

    for idx, i in enumerate(positions):
        sub_shaders['invlinear'][1].CreateInput('key' + str(idx), Sdf.ValueTypeNames.Float).GetAttr().Set(i)
        sub_shaders['uniformramp'][1].CreateInput(
            'value' + str(idx), Sdf.ValueTypeNames.Float).GetAttr().Set(values[idx])
    shader.GetIdAttr().Set('')
    shader.GetOutput('out').ConnectToSource(sub_shaders['uniformramp'][1].CreateOutput('out', Sdf.ValueTypeNames.Float))
    UsdShade.NodeGraph.Define(stage, shader.GetPrim().GetPath())
    check_inputs(shader)

def convert_ao(shader):
    shader.GetIdAttr().Set('ND_ambientocclusion_float')


def convert_facing_ratio(shader):
    shader.GetIdAttr().Set('ND_hmtlxfacingratio_float')

def convert_noise(shader):
    output_names = [x.GetBaseName() for x in shader.GetOutputs()]
    if 'out' in output_names:
        shader.GetIdAttr().Set('ND_noise2d_color3')
        shader.CreateOutput('out', Sdf.ValueTypeNames.Color3f)
    else:
        shader.GetIdAttr().Set('ND_noise2d_float')
        shader.CreateOutput('out', Sdf.ValueTypeNames.Float)
    check_inputs(shader)


shader_ls = hou.LopSelectionRule('%type:Shader')
material_ls = hou.LopSelectionRule('%type:Material')


material_paths = material_ls.expandedPaths(stage=stage)
shaser_paths = shader_ls.expandedPaths(stage=stage)

for path in material_paths:
    material = UsdShade.Material.Define(stage, path)
    convert_material(material)

for path in shaser_paths:
    shader = UsdShade.Shader.Define(stage, path)

    id = shader.GetIdAttr().Get()
    if id == 'arnold:standard_surface':
        convert_standard_surface(shader)
    elif id == 'arnold:image':
        convert_image(shader)
    elif id == 'arnold:normal_map':
        convert_normalmap(shader)
    elif id == 'arnold:range':
        convert_range(shader)
    elif id == 'arnold:clamp':
        convert_clamp(shader)
    elif id == 'arnold:layer_shader':
        convert_layer(shader)
    elif id == 'arnold:color_correct':
        convert_color_correct(shader)
    elif id == 'arnold:ambient_occlusion':
        convert_ao(shader)
    elif id == 'arnold:facing_ratio':
        convert_facing_ratio(shader)
    elif id == 'arnold:ramp_rgb':
        convert_ramp_rgb(shader)
    elif id == 'arnold:ramp_float':
        convert_ramp_float(shader)
    elif id == 'arnold:noise':
        convert_noise(shader)"	)
maintainstate	[ 0	locks=0 ]	(	"off"	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/pythonscript2.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":"___EXTERNAL___"
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/output0.init"
Content-Type: text/plain

type = output
matchesdef = 1

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/output0.def"
Content-Type: text/plain

comment ""
position 5.55112e-17 5.2176
connectornextid 1
flags =  lock off model off template off footprint off xray off bypass off display on render off highlight off unload off savedata off compress on colordefault on exposed on debug off
outputsNamed3
{
}
inputsNamed3
{
0 	pythonscript2 1 1 "input1"
}
inputs
{
0 	pythonscript2 0 1
}
stat
{
  create -1
  modify -1
  author chord@LAPTOP-ULJICLO8
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/output0.parm"
Content-Type: text/plain

{
version 0.8
outputidx	[ 0	locks=0 ]	(	0	)
modifiedprims	[ 0	locks=0 ]	(	"`lopinputprims(\".\", 0)`"	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/output0.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":"___EXTERNAL___"
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.order"
Content-Type: text/plain

2
pythonscript2
output0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.net"
Content-Type: text/plain

1

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY--
